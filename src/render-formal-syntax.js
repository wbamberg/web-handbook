import { definitionSyntax } from "css-tree";
import { renderCallout } from "./render-utils.js";

// URL where we describe value definition syntax
const valueDefinitionUrl = `/en-US/docs/Web/CSS/Value_definition_syntax`;

// Descriptions used for building links and tooltips for parts of the value definition syntax
const syntaxDescriptions = {
	"*": {
		fragment: "asterisk",
		tooltip: "Asterisk: the entity may occur zero, one or several times",
	},
	"+": {
		fragment: "plus",
		tooltip: "Plus: the entity may occur one or several times",
	},
	"?": {
		fragment: "question_mark",
		tooltip: "Question mark: the entity is optional",
	},
	"{}": {
		fragment: "curly_braces",
		tooltip:
			"Curly braces: encloses two integers defining the minimal and maximal numbers of occurrences of the entity, or a single integer defining the exact number required",
	},
	"#": {
		fragment: "hash_mark",
		tooltip:
			"Hash mark: the entity is repeated one or several times, each occurence separated by a comma",
	},
	"!": {
		fragment: "exclamation_point_!",
		tooltip: "Exclamation point: the group must produce at least one value",
	},
	"[]": {
		fragment: "brackets",
		tooltip:
			"Brackets: enclose several entities, combinators, and multipliers to transform them as a single component",
	},
	"|": {
		fragment: "single_bar",
		tooltip: "Single bar: exactly one of the entities must be present",
	},
	"||": {
		fragment: "double_bar",
		tooltip:
			"Double bar: one or several of the entities must be present, in any order",
	},
	"&&": {
		fragment: "double_ampersand",
		tooltip:
			"Double ampersand: all of the entities must be present, in any order",
	},
};

/**
 * Get the markup for a multiplier, including links to the value definition syntax.
 */
function renderMultiplier(multiplierName) {
	let key = multiplierName;
	// remove number inside `{}` multiplier
	if (multiplierName.startsWith("{")) {
		key = "{}";
	}
	// these two multiplier combinations can appear, we want to annotate them separately
	if (multiplierName === "+#" || multiplierName === "#?") {
		const info1 = syntaxDescriptions[multiplierName[0]];
		const info2 = syntaxDescriptions[multiplierName[1]];
		const link1 = `<a href="${valueDefinitionUrl}#${info1.fragment}" title="${info1.tooltip}">${multiplierName[0]}</a>`;
		const link2 = `<a href="${valueDefinitionUrl}#${info2.fragment}" title="${info2.tooltip}">${multiplierName[1]}</a>`;
		return `${link1}${link2}`;
	}
	// the "#" multipler can be followed by the curly brackets, we want to annotate them separately
	if (multiplierName.startsWith("#{")) {
		const info1 = syntaxDescriptions["#"];
		const info2 = syntaxDescriptions["{}"];
		const link1 = `<a href="${valueDefinitionUrl}#${info1.fragment}" title="${info1.tooltip}">${multiplierName[0]}</a>`;
		const link2 = `<a href="${valueDefinitionUrl}#${info2.fragment}" title="${
			info2.tooltip
		}">${multiplierName.slice(1)}</a>`;
		return `${link1}${link2}`;
	}
	const info = syntaxDescriptions[key];
	return `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">${multiplierName}</a>`;
}

/**
 * Determines the markup to generate for a single node in the AST
 * generated by css-tree.
 */
function renderNode(name, node) {
	switch (node.type) {
		case "Property": {
			let target = name.replaceAll("<", "");
			target = target.replaceAll(">", "");
			target = target.replaceAll("'", "");
			return `<span class="token property"><a href="${target}.html">${name}</a></span>`;
		}
		case "Type": {
			// encode < and >
			let encoded = name.replaceAll("<", "&lt;");
			encoded = encoded.replaceAll(">", "&gt;");
			// add CSS class: we use "property" because there isn't one for types
			return `<span class="token property">${encoded}</span>`;
		}
		case "Multiplier": {
			// link to the value definition syntax and provide a tooltip
			return renderMultiplier(name);
		}
		case "Keyword": {
			return `<span class="token keyword">${name}</span>`;
		}
		case "Function": {
			return `<span class="token function">${name}</span>`;
		}
		case "Token": {
			if (name === ")") {
				// this is a closing bracket
				return `<span class="token function">${name}</span>`;
			}
		}
		// eslint-disable-next-line no-fallthrough
		case "Group": {
			// link from brackets to the value definition syntax docs
			const info = syntaxDescriptions["[]"];
			name = name.replace(
				/^\[/,
				`<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">[</a>`,
			);
			name = name.replace(
				/\]$/,
				`<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">]</a>`,
			);

			// link from combinators (except " ") to the value definition syntax docs
			if (node.combinator && node.combinator !== " ") {
				const info = syntaxDescriptions[node.combinator];
				// note that we are replacing the combinator surrounded by spaces, like " | "
				name = name.replaceAll(
					` ${node.combinator} `,
					` <a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">${node.combinator}</a> `,
				);
			}

			return name;
		}
		default:
			return name;
	}
}

/**
 * Generate the markup for every term in a syntax definition,
 * ensuring that the terms are visually aligned
 */
function renderTerms(terms, combinator) {
	let output = "";
	const renderedTerms = [];

	for (const term of terms) {
		// figure out the lengths of the translated terms, without markup
		// this is just so we can align the terms properly
		const termTextLength = definitionSyntax.generate(term).length;
		// get the translated terms, with markup
		const termText = definitionSyntax.generate(term, {
			decorate: renderNode,
		});
		renderedTerms.push({
			text: termText,
			length: termTextLength,
		});
	}

	// we will space-pad all terms to the length of the longest term,
	// so that lines are aligned, but padding must not cause lines to wrap,
	// so the target width is clamped to the line length.
	const maxLineLength = 50;
	let maxTermLength = Math.max(...renderedTerms.map((t) => t.length));
	maxTermLength = Math.min(maxTermLength, maxLineLength);

	// write out the translated terms, padding with spaces for alignment
	// and separating terms using their combinator symbol
	for (let i = 0; i < renderedTerms.length; i++) {
		const termText = renderedTerms[i].text;
		const spaceCount = Math.max(2, maxTermLength + 2 - renderedTerms[i].length);
		let combinatorText = "";
		if (combinator && combinator !== " ") {
			const info = syntaxDescriptions[combinator];
			// link from combinators (except " ") to the value definition syntax docs
			combinatorText = `<a href="${valueDefinitionUrl}#${info.fragment}" title="${info.tooltip}">${combinator}</a>`;
		}
		// omit the combinator for the final term
		combinatorText = i < renderedTerms.length - 1 ? combinatorText : "";
		output += `  ${termText}${" ".repeat(spaceCount)}${combinatorText}<br/>`;
	}

	return output;
}

/**
 * Render the syntax for a single item.
 */
function renderSyntaxItem(type, syntax) {
	// write out the name of this type
	type = type.replaceAll("<", "&lt;");
	type = type.replaceAll(">", "&gt;");
	let output = `<span class="token property" id="${type}">${type} = </span><br/>`;
	const ast = definitionSyntax.parse(syntax);
	// if the combinator is ' ', write the complete type syntax in a single line
	if (ast.combinator === " ") {
		output += renderTerms([ast], ast.combinator);
	} else {
		// otherwise write out each direct child in its own line
		output += renderTerms(ast.terms, ast.combinator);
	}

	return output;
}

function renderConstituents(constituents) {
	let output = '<pre class="formal-syntax">';

	for (const constituent of constituents) {
		output = `${output}${renderSyntaxItem(
			constituent.type,
			constituent.syntax,
		)}<br>`;
	}

	return `${output}</pre>`;
}

export function renderFormalSyntax(name, definition) {
	let output = `<pre class="formal-syntax">${renderSyntaxItem(
		name,
		definition.syntax,
	)}</pre>`;

	const renderedConstituents =
		definition.constituentslength === 0
			? ""
			: renderCallout(
					`<details><summary>Constituent types</summary>${renderConstituents(
						definition.constituents,
					)}</details>`,
					"callout",
			  );

	output = `${output}${renderedConstituents}`;
	return output;
}
